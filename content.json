{"pages":[{"title":"","text":"","link":"/album/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事Android移动开发 博客信息 网站主题为amazing，其原主题为Icarus主题 追求尽可能的简洁，清晰，易用。 更新日志：–2021.06.25：创建博客","link":"/about/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://gitee.com/GP9/pic-rep/raw/master/img/logo.jpg 网站名称：平平的马路 网站地址：https://blockh.github.io 网站简介：Coding the world 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'e1499f734d835660ddff', clientSecret: 'b655baa951b1817cb47f173e1b337b1f47cb57d2', id: 'Pinguoooo', repo: 'blog_comment', owner: 'blockh', admin: \"blockh\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Android-使用友盟分享微信小程序到微信","text":"Android使用友盟分享微信小程序到微信在友盟官网上看到了相关的API，但是总是无法正常调用，下面记录下自己的处理流程： 引入依赖12345implementation 'com.umeng.umsdk:common:2.2.5'implementation 'com.umeng.umsdk:share-core:7.0.2'implementation 'com.umeng.umsdk:share-board:7.0.2'//为支持微信分享的模块implementation 'com.umeng.umsdk:share-wx:7.0.2' 添加所需权限，创建微信所需的Activity请在AndroidManifest中添加如下权限 12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;&gt;&lt;/uses-permission&gt; 并在AndroidManifest中添加如下代码(需要提前创建好Activity)： 1234567&lt;activity android:configchanges=&quot;keyboardHidden|orientation|screenSize&quot; android:exported=&quot;true&quot; android:launchmode=&quot;singleTask&quot; android:name=&quot;.wxapi.WXEntryActivity&quot; android:taskaffinity=&quot;net.sourceforge.simcpux&quot; android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot;&gt;&lt;/activity&gt; 在你的项目包中创建wxapi包，并创建WXEntryActivity.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class WXEntryActivity extends WXCallbackActivity implements IWXAPIEventHandler { private IWXAPI wxapi= BaseApplication.getInstance().getWxApi(); @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); setIntent(intent); wxapi.handleIntent(intent, this); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); wxapi.handleIntent(getIntent(), this); } @Override public void onReq(BaseReq baseReq) { LogUtils.d(baseReq:+baseReq.openId); } @Override public void onResp(BaseResp baseResp) { if (baseResp.getType()==ConstantsAPI.COMMAND_SENDMESSAGE_TO_WX){ finish(); }else if(baseResp.getType()==ConstantsAPI.COMMAND_SENDAUTH){ LogUtils.d(返回授权+baseResp.errCode); switch (baseResp.errCode) { case BaseResp.ErrCode.ERR_OK: LogUtils.d(返回Code：+((SendAuth.Resp) baseResp).code); EventBus.getDefault().post(new EventMessage(CodeManager.BIND_PHONE,((SendAuth.Resp) baseResp).code)); break; case BaseResp.ErrCode.ERR_USER_CANCEL: case BaseResp.ErrCode.ERR_AUTH_DENIED: case BaseResp.ErrCode.ERR_UNSUPPORT: break; } finish(); } } } 由于我在项目中集成了其他微信相关的SDK，读者只用关注这个 WXEntryActivity需要继承 WXCallbackActivity 以及实现 IWXAPIEventHandler 这两个类。 在自定义的 BaseApplication 的 onCreate 方法中需要注册友盟1234567891011121314151617181920 ... @Override public void onCreate() { super.onCreate(); initUmeng(); }private void initUmeng() { // 在此处调用基础组件包提供的初始化函数 相应信息可在应用管理 -&gt; 应用信息 中找到 http://message.umeng.com/list/apps // 参数一：当前上下文context； // 参数二：应用申请的Appkey； // 参数三：渠道名称； // 参数四：设备类型，必须参数，传参数为UMConfigure.DEVICE_TYPE_PHONE则表示手机；传参数为UMConfigure.DEVICE_TYPE_BOX则表示盒子；默认为手机； // 参数五：Push推送业务的secret 填充Umeng Message Secret对应信息（需替换） UMConfigure.init(this, 应用在友盟申请的Appkey, Umeng, UMConfigure.DEVICE_TYPE_PHONE, 没有使用推送服务，传空字符串就行); //开通微信分享 第一个值为app在微信注册时的AppID 第二个值是你们软件注册时的AppSecret PlatformConfig.setWeixin(wx*************, *******AppSecret****);} 注意！这里一定要添加开通微信分享的代码，否则点击分享按钮将没有任何反应！！！ PlatformConfig.setWeixin(&quot;wx*************&quot;, &quot;*******AppSecret****&quot;); 分享小程序到微信我将分享逻辑放在弹窗点击事件里 12345678910111213141516171819202122232425262728293031323334353637383940414243private void showShareDialog(DistributionMyGoodsBean.ListBean listBean) { //分享 ShareDialog shareDialog = new ShareDialog(mContext, false); shareDialog.setOnButtonListener(new ShareDialog.OnButtonListener() { @Override public void onWeChatClick() { ToastUtils.showShort(微信分享); //兼容低版本的网页链接 UMMin umMin = new UMMin(你想要兼容的网页链接，需要带上http://); // 小程序消息封面图片 umMin.setThumb(new UMImage(mContext, listBean.getImage())); // 小程序消息title umMin.setTitle(listBean.getTitle()); //小程序页面路径 umMin.setPath(/pages/小程序对应的页面链接); //小程序原始id,在微信平台查询 umMin.setUserName(gh_***********); //设置小程序版本 //预览版 Config.setMiniPreView(); //测试版 Config.setMiniTest(); new ShareAction((Activity) mContext) .setPlatform(SHARE_MEDIA.WEIXIN) .withMedia(umMin) .setCallback(shareListener) .share(); } @Override public void onCircleFriendsClick() { //小程序目前无法分享小程序到朋友圈 } }); shareDialog.show();} 注意：在分享小程序之前是必须要设置小程序的版本的，不然点开微信链接会报错","link":"/2021/06/25/Android-%E4%BD%BF%E7%94%A8%E5%8F%8B%E7%9B%9F%E5%88%86%E4%BA%AB%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%B0%E5%BE%AE%E4%BF%A1/"},{"title":"Android-基类PopupWindow创建及使用","text":"BasePopupWindow主要功能 实现了弹出时背景半透明效果 实现 BasePopupWindow.java 12345678910111213141516171819202122232425262728public class BasePopupWindow extends PopupWindow { private Activity activity; public BasePopupWindow(Activity activity) { this.activity = activity; } /** * 设置页面的透明度 * @param bgAlpha 1表示不透明 */ public void setBackgroundAlpha(float bgAlpha) { WindowManager.LayoutParams lp = activity.getWindow().getAttributes(); lp.alpha = bgAlpha; if (bgAlpha == 1) { activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);//不移除该Flag的话,在有视频的页面上的视频会出现黑屏的bug } else { activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);//此行代码主要是解决在华为手机上半透明效果无效的bug } activity.getWindow().setAttributes(lp); } public void onDismiss() { if (activity != null) { setBackgroundAlpha(1f); } }} 例子 实现选择车辆的弹出选择框 TruckPop.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import android.app.Activity;import android.graphics.Color;import android.graphics.drawable.ColorDrawable;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import androidx.annotation.NonNull;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import com.chad.library.adapter.base.BaseQuickAdapter;import com.chad.library.adapter.base.listener.OnItemClickListener;import com.hhkj.mcb.R;import com.hhkj.mcb.common.ui.bean.CarBean;import com.hhkj.mcb.seller.callbuy.adapter.TruckAdapter;import java.util.List;import butterknife.BindView;import butterknife.ButterKnife;/** * @ClassName: TruckPop * @Description: * @Author: pinguoooo * @Date: 2020/12/11 13:57 */public class TruckPop extends BasePopupWindow { @BindView(R.id.rv_truck) RecyclerView rvTruck; private final View view; private Activity activity; private List&lt;CarBean&gt; carBeanList; private TruckAdapter truckAdapter; private OnSelectedListener onSelectedListener; private int selectIndex = 0; public TruckPop(Activity activity, int height, List&lt;CarBean&gt; carBeanList) { this(activity,height,carBeanList,0); } public TruckPop(Activity activity, int height, List&lt;CarBean&gt; carBeanList, int selectIndex) { super(activity); this.activity = activity; this.carBeanList = carBeanList; this.selectIndex = selectIndex; setOutsideTouchable(true); setFocusable(true); setWidth(ViewGroup.LayoutParams.MATCH_PARENT); setHeight(height); setBackgroundDrawable(new ColorDrawable(0x30000000)); view = LayoutInflater.from(activity).inflate(R.layout.pop_truck, null); setContentView(view); ButterKnife.bind(this, view); initView(); } private void initView() { view.setOnClickListener(view -&gt; { dismiss(); }); rvTruck.setLayoutManager(new LinearLayoutManager(activity)); rvTruck.setAdapter(truckAdapter = new TruckAdapter(R.layout.truck_item,selectIndex)); View headerView = LayoutInflater.from(activity).inflate(R.layout.truck_item, null); TextView header = headerView.findViewById(R.id.tv_carNumber); headerView.setBackgroundColor(Color.WHITE); header.setText(&quot;全部&quot;); header.setTextColor(Color.parseColor(&quot;#31C863&quot;)); truckAdapter.addHeaderView(headerView); truckAdapter.setList(carBeanList); truckAdapter.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(@NonNull BaseQuickAdapter&lt;?, ?&gt; adapter, @NonNull View view, int position) { CarBean carBean = (CarBean) adapter.getData().get(position); truckAdapter.setSelectIndex(position); if (onSelectedListener != null) { onSelectedListener.onSelect(carBean, position); } } }); } public interface OnSelectedListener { void onSelect(CarBean carBean, int position); } public OnSelectedListener getOnSelectedListener() { return onSelectedListener; } public void setOnSelectedListener(OnSelectedListener onSelectedListener) { this.onSelectedListener = onSelectedListener; }} pop_truck.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/rv_truck&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; TruckAdapter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import android.graphics.Color;import com.blankj.utilcode.util.ToastUtils;import com.chad.library.adapter.base.BaseQuickAdapter;import com.chad.library.adapter.base.viewholder.BaseViewHolder;import com.hhkj.mcb.R;import com.hhkj.mcb.common.ui.bean.CarBean;import org.jetbrains.annotations.NotNull;import org.jetbrains.annotations.Nullable;import java.util.List;/** * @ClassName: PickUpAdapter * @Description: * @Author: pinguoooo * @Date: 2020/11/9 11:29 */public class TruckAdapter extends BaseQuickAdapter&lt;CarBean, BaseViewHolder&gt; { private int selectIndex; public TruckAdapter(int layoutResId, @Nullable List&lt;CarBean&gt; data, int selectIndex) { super(layoutResId, data); this.selectIndex = selectIndex; } public TruckAdapter(int layoutResId, int selectIndex) { super(layoutResId); this.selectIndex = selectIndex; ToastUtils.showShort(selectIndex); } @Override protected void convert(@NotNull BaseViewHolder baseViewHolder, CarBean carBean) { //因为添加了列表头部，在获取位置索引时需要 -1 if (selectIndex == baseViewHolder.getLayoutPosition() - 1) { //LogUtils.d(&quot;layoutPosition:&quot; + baseViewHolder.getLayoutPosition()); baseViewHolder.itemView.setBackgroundColor(Color.WHITE); baseViewHolder.setTextColor(R.id.tv_carNumber, Color.parseColor(&quot;#31C863&quot;)); } else { baseViewHolder.itemView.setBackgroundColor(Color.parseColor(&quot;#F7F7F7&quot;)); baseViewHolder.setTextColor(R.id.tv_carNumber, Color.parseColor(&quot;#666666&quot;)); } } public void setSelectIndex(int selectIndex) { this.selectIndex = selectIndex; //LogUtils.d(&quot;selectIndex:&quot; + selectIndex); notifyDataSetChanged(); } public int getSelectIndex() { return selectIndex; }} 效果如下","link":"/2021/06/25/Android-%E5%9F%BA%E7%B1%BBPopupWindow%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"title":"Android-处理多层Viewpager滑动冲突","text":"处理多层ViewPage嵌套产生滑动冲突的问题场景在项目中我们经常会遇到一下类似的嵌套效果，ViewPager从主页可以一直右滑经过每个页面。 123456789graph LRA(MainActivity: BottomNavigationView + ViewPager)--&gt;B1(主页 : TabLayout + ViewPager)A--&gt;B2(发现 : TabLayout + ViewPager)A--&gt;B3(我的 : 普通布局)B1--&gt;C1(tab1 : TabLayout + ViewPager)--&gt;RecycleView1--&gt;items1B1--&gt;C2(tab1 : TabLayout + ViewPager)--&gt;RecycleView2--&gt;items2B1--&gt;C3(tab1 : TabLayout + ViewPager)--&gt;RecycleView3--&gt;items3B2--&gt;D1(tab1....)B3--&gt;E1(内容) 效果图 实际开发的时候，我们往往第一时间想到嵌套以上类似布局直接实现想要的效果。但总是会出现莫名奇妙的闪退效果，抛数组越界异常，其实问题就出现在嵌套的ViewPager左右滑动时，子Viewpager划到最右一页继续滑动时，Viewpager并不会吧触摸事件交给父ViewPager响应，而此时的子ViewPager已经到了末尾一页，继续右滑调用下一页当然会抛越界异常。 解决其实这个问题很好解决，核心思想就是重写子ViewPager的触摸监听事件，当子ViewPager在首页向左滑动或末尾页向右滑动时，触摸响应交给父ViewPager来处理。 将原本的子ViewPager改为自定义的 ChildViewPager.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @ClassName: ChildViewPager * @Description: * @Author: pinguoooo * @Date: 2020/8/12 9:49 */public class ChildViewPager extends ViewPager { int startX; int startY; public ChildViewPager(@NonNull Context context) { super(context); } public ChildViewPager(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } @Override public boolean dispatchTouchEvent(MotionEvent ev) { //页面当前位置 int currentPosition; //总页数 int count = Objects.requireNonNull(getAdapter()).getCount(); switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: startX = (int) ev.getRawX(); //startY = (int) ev.getY(); //申请让父View 不要拦截触摸事件 getParent().requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int endX = (int) ev.getRawX(); int disX = endX - startX; currentPosition = this.getCurrentItem(); //最后一页且往左滑，由父View拦截触摸事件 if (currentPosition == count - 1 &amp;&amp; disX &lt; 0) { //申请让父View拦截触摸事件 getParent().requestDisallowInterceptTouchEvent(false); } //第一页且右滑，由父View拦截触摸事件 else if (currentPosition == 0 &amp;&amp; disX &gt; 0) { //申请让父View拦截触摸事件 getParent().requestDisallowInterceptTouchEvent(false); } //其他情况，由自己拦截 else { //申请让父View拦截触摸事件 getParent().requestDisallowInterceptTouchEvent(true); } break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: getParent().requestDisallowInterceptTouchEvent(false); break; } return super.dispatchTouchEvent(ev); }} 其实核心想法就是，子ViewPager 在需要的时候让 父Viewpager 拦截触摸事件 关键语句： 1getParent().requestDisallowInterceptTouchEvent(Boolean); 使用使用方式就按上述简单的思维导图来嵌套就OK了 最外层 activity_main.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.main.MainActivity&quot;&gt; &lt;androidx.viewpager.widget.ViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_above=&quot;@+id/bottom_nav&quot;/&gt; &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=&quot;@+id/bottom_nav&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;#fcfcfc&quot; app:itemIconTint=&quot;@color/bottom_nav_color_selector&quot; app:itemTextColor=&quot;@color/bottom_nav_color_selector&quot; app:menu=&quot;@menu/nav_tab_menu&quot;/&gt;&lt;/RelativeLayout&gt; 第一层ViewPager fragement_home.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:context=&quot;XXX.XXX.XXX&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=&quot;@+id/appBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_scrollFlags=&quot;enterAlways|scroll&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;com.google.android.material.tabs.TabLayout android:id=&quot;@+id/tabs&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabIndicatorColor=&quot;@color/colorPrimary&quot; app:tabMode=&quot;scrollable&quot;/&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;com.liuguoping.pretty_gank.gank.view.ChildViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:focusable=&quot;true&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; android:focusableInTouchMode=&quot;true&quot;/&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 第二层ViewPager fragment_home_tab.xml 123456789101112131415161718192021222324&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;XXX.XXX.XXX&quot;&gt; &lt;com.google.android.material.tabs.TabLayout android:id=&quot;@+id/tabs_child&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabIndicatorColor=&quot;@color/colorPrimary&quot; app:tabMode=&quot;scrollable&quot; /&gt; &lt;com.liuguoping.pretty_gank.gank.view.ChildViewPager android:id=&quot;@+id/viewpager_child&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; /&gt;&lt;/LinearLayout&gt; 继续嵌套最里层的 RecycleView 所在的 Fragment fragment_home_tab_list.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.scwang.smartrefresh.layout.SmartRefreshLayout android:id=&quot;@+id/smartRefresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.scwang.smartrefresh.layout.header.ClassicsHeader android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/rv_gank_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;4dp&quot; /&gt; &lt;com.scwang.smartrefresh.layout.footer.ClassicsFooter android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/com.scwang.smartrefresh.layout.SmartRefreshLayout&gt;&lt;/LinearLayout&gt; 总结将控制 父ViewPager 触摸事件的拦截与否交给 子ViewPager 的好处是这样可以灵活处理当前的滑动触摸事件，不用担心下一层是否继续嵌套了ViewPager。","link":"/2021/06/25/Android-%E5%A4%84%E7%90%86%E5%A4%9A%E5%B1%82Viewpager%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"},{"title":"Android-虚拟导航键显示隐藏监听及自动设定高度","text":"虚拟导航键显示隐藏监听及自动设定高度问题描述某些型号在某些布局下使用虚拟导航栏不能自动调整布局，导致遮挡。特别是华为手机。。。 问题解决步骤 获取根布局 设置 ViewTree 的全局界面监听 当捕获到界面更新时，去判断虚拟导航键是否弹出或隐藏然后做出相应的操作 实现1. 获取根布局123456789101112131415161718192021public class MainActivity implements ViewTreeObserver.OnGlobalLayoutListener{//虚拟导航栏自适应FrameLayout content;private boolean mLayoutComplete = false; ...@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); content = (FrameLayout) findViewById(android.R.id.content);}//捕获界面监听@Overridepublic void onGlobalLayout() { ...} ...} 2. 设置监听12345678910111213@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); content = (FrameLayout) findViewById(android.R.id.content); content.post(new Runnable() { @Override public void run() { mLayoutComplete = true; LogUtils.d(&quot;content 布局完成&quot;); } }); content.getViewTreeObserver().addOnGlobalLayoutListener(this);} 3. 捕获监听事件并做出虚拟导航是否隐藏的相应操作捕获监听123456@Overridepublic void onGlobalLayout() { LogUtils.d(&quot;onGlobalLayout&quot;); if (!mLayoutComplete) return; onNavigationBarStatusChanged();} 虚拟导航是否隐藏的相应操作在这里我判断虚拟导航键是否弹出的依据是 当前屏幕真实高度 是否大于 屏幕高度 。 123456789protected void onNavigationBarStatusChanged() { //这里的操作是为虚拟导航键留出相应高度，以适应某些型号在使用虚拟导航栏不能自动调整布局，导致遮挡。 if (ScreenUtils.getRealHeight() &gt; ScreenUtils.getHeight()) { getWindow().getDecorView().findViewById(android.R.id.content).setPadding(0, 0, 0,ScreenUtils.getNavigationBarHeight(this)); getWindow().setNavigationBarColor(Color.parseColor(&quot;#000000&quot;)); } else { getWindow().getDecorView().findViewById(android.R.id.content).setPadding(0, 0, 0, 0); }} 4.其他方法12345678910111213141516171819202122232425262728293031323334353637383940414243public class ScreenUtils { /** * 非全面屏下 虚拟键高度(无论是否隐藏) * @param context * @return */ public static int getNavigationBarHeight(Context context){ int result = 0; int resourceId = context.getResources().getIdentifier(&quot;navigation_bar_height&quot;,&quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { result = context.getResources().getDimensionPixelSize(resourceId); } return result; } /** * 获取手机屏幕高度 */ public static int getHeight() { DisplayMetrics dm = new DisplayMetrics(); WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); windowManager.getDefaultDisplay().getMetrics(dm); return dm.heightPixels; } /** * 获取屏幕真实高度（包括虚拟键盘） * */ public static int getRealHeight() { WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); DisplayMetrics dm = new DisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { display.getRealMetrics(dm); } else { display.getMetrics(dm); } int realHeight = dm.heightPixels; return realHeight; } } 总结以下为封装代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @ClassName: ScreenUtils * @Description: * @Author: pinguoooo * @Date: 2020/9/1 13:48 */public class ScreenUtils { /** * 非全面屏下 虚拟键高度(无论是否隐藏) * * @param context * @return */ public static int getNavigationBarHeight(Context context) { int result = 0; int resourceId = context.getResources().getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { result = context.getResources().getDimensionPixelSize(resourceId); } return result; } /** * 获取手机屏幕高度 */ public static int getHeight() { DisplayMetrics dm = new DisplayMetrics(); WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); windowManager.getDefaultDisplay().getMetrics(dm); return dm.heightPixels; } /** * 获取屏幕真实高度（包括虚拟键盘） */ public static int getRealHeight() { WindowManager windowManager = (WindowManager) BaseApplication.getInstance().getSystemService(Context.WINDOW_SERVICE); Display display = windowManager.getDefaultDisplay(); DisplayMetrics dm = new DisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { display.getRealMetrics(dm); } else { display.getMetrics(dm); } int realHeight = dm.heightPixels; return realHeight; } public interface NavigationListener { void show(); void hide(); } //虚拟导航栏显示/隐藏 public static void setNavigationListener(final View rootView, final NavigationListener navigationListener) { if (rootView == null || navigationListener == null) { return; } rootView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { if (ScreenUtils.getRealHeight() &gt; ScreenUtils.getHeight()) { //显示虚拟按键 if (navigationListener != null) { navigationListener.show(); } } else { //隐藏虚拟按键 if (navigationListener != null) { navigationListener.hide(); } } } }); }} 注： 在使用 setNavigationListener 时，传入的 rootView 为对应的 android.R.id.content 布局（FrameLayout 类型），传入别的可能没有效果。在这里我判断虚拟导航键是否弹出的依据是 当前屏幕真实高度 是否大于 屏幕高度 。 之后在使用时只需要对出现虚拟导航栏出现覆盖问题的 Activity 添加对 rootView 的监听，即可方便的实现虚拟导航栏隐藏与显示的监听。 12345678910111213141516@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); content = (FrameLayout) findViewById(android.R.id.content); ScreenUtils.setNavigationListener(content, new ScreenUtils.NavigationListener() { @Override public void show() { // 虚拟导航栏显示的操作 } @Override public void hide() { // 虚拟导航栏隐藏的操作 } });}","link":"/2021/06/25/Android-%E8%99%9A%E6%8B%9F%E5%AF%BC%E8%88%AA%E9%94%AE%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E7%9B%91%E5%90%AC%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%AE%BE%E5%AE%9A%E9%AB%98%E5%BA%A6/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"PopupWindow","slug":"PopupWindow","link":"/tags/PopupWindow/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"View","slug":"Android/View","link":"/categories/Android/View/"}]}